#!/usr/bin/env bash
set -euo pipefail

# Rails
RAILS_ENV="end_to_end"
RAILS_PORT="4100"
HEALTH_CHECK_URL="http://localhost:${RAILS_PORT}/up"
MAVIS_TEST_REPO="${MAVIS_TEST_REPO:-"../manage-vaccinations-in-schools-testing"}"
E2E_REDIS_URL="redis://localhost:6380/0"

# Argument handling

if [ $# -lt 1 ]; then
  echo "Usage: bin/e2e [--main] [pytest args...] <pytest-target>"
  echo "  Example:"
  echo "    bin/e2e --main --headed tests/test_start.py::test_start_page_elements_visible"
  exit 1
fi

if ! command -v uv >/dev/null 2>&1; then
  echo "[e2e] ERROR: 'uv' is not installed or not on PATH." >&2
  echo "       Install uv: https://github.com/astral-sh/uv" >&2
  exit 1
fi

if [ ! -d "$MAVIS_TEST_REPO/.git" ]; then
  echo "[e2e] ERROR: Testing repo not found at: $MAVIS_TEST_REPO" >&2
  echo "      Clone the repo there or set the MAVIS_TEST_REPO" >&2
  echo "      environment variable to the path of your repo" >&2
  exit 1
fi

# Consume --main flag if present
USE_MAVIS_BRANCH=false
PYTEST_ARGS=()

for arg in "$@"; do
  case "$arg" in
    --main)
      USE_MAVIS_BRANCH=true
      ;;
    *)
      PYTEST_ARGS+=("$arg")
      ;;
  esac
done

# Update mavis testing repo
if [ "${USE_MAVIS_BRANCH:-false}" = true ]; then
  echo "[e2e] Using latest main branch of testing repo."
  pushd "$MAVIS_TEST_REPO" > /dev/null

  git fetch origin
  git checkout main
  git reset --hard origin/main

  echo "[e2e] Syncing Python dependencies with uv..."
  uv sync

  popd > /dev/null
else
  echo "[e2e] Checking branch alignment with testing repo..."

  # Service (main) repo branch
  MAVIS_REPO="$(git rev-parse --show-toplevel 2>/dev/null || echo "")"
  MAVIS_BRANCH="unknown"
  if [ -n "$MAVIS_REPO" ]; then
    MAVIS_BRANCH="$(git -C "$MAVIS_REPO" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD")"
  fi

  # Testing repo branch
  MAVIS_TEST_BRANCH="unknown"
  if git -C "$MAVIS_TEST_REPO" rev-parse --git-dir >/dev/null 2>&1; then
    MAVIS_TEST_BRANCH="$(git -C "$MAVIS_TEST_REPO" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD")"
  fi

  # If testing repo is on main, warn if it's behind origin/main
  if [ "$MAVIS_TEST_BRANCH" = "main" ]; then
    # Fetch without failing the whole script if it goes wrong
    git -C "$MAVIS_TEST_REPO" fetch origin main >/dev/null 2>&1 || true

    LOCAL_MAIN_SHA="$(git -C "$MAVIS_TEST_REPO" rev-parse main 2>/dev/null || echo "")"
    REMOTE_MAIN_SHA="$(git -C "$MAVIS_TEST_REPO" rev-parse origin/main 2>/dev/null || echo "")"

    if [ -n "$LOCAL_MAIN_SHA" ] && [ -n "$REMOTE_MAIN_SHA" ] && [ "$LOCAL_MAIN_SHA" != "$REMOTE_MAIN_SHA" ]; then
      AHEAD_BEHIND="$(git -C "$MAVIS_TEST_REPO" rev-list --left-right --count main...origin/main 2>/dev/null || echo "")"
      set -- $AHEAD_BEHIND
      LOCAL_AHEAD="$1"
      LOCAL_BEHIND="$2"

      # Warn if local main differs from remote
      if [ -n "$LOCAL_BEHIND" ] && [ "$LOCAL_BEHIND" -gt 0 ] 2>/dev/null; then
        echo "[e2e] !!! WARNING !!! Testing repo 'main' is behind origin/main by $LOCAL_BEHIND commit(s)."
        echo "[e2e]                 Run 'git -C \"$MAVIS_TEST_REPO\" pull --ff-only origin main' "
        echo "[e2e]                 or use --main to force-sync."
      elif [ -n "$LOCAL_AHEAD" ] && [ "$LOCAL_AHEAD" -gt 0 ] 2>/dev/null; then
        echo "[e2e] !!! WARNING !!! Testing repo 'main' is ahead of  origin/main by $LOCAL_AHEAD commit(s)."
        echo "[e2e]                 Run 'git -C \"$MAVIS_TEST_REPO\" pull --ff-only origin main' "
        echo "[e2e]                 or use --main to force-sync."
      fi
    else
      echo "[e2e] Testing repo 'main' branch is up to date with origin/main."
    fi
  elif [ "$MAVIS_BRANCH" != "$MAVIS_TEST_BRANCH" ]; then
      echo "[e2e] !!! WARNING !!! Service repo branch ($MAVIS_BRANCH) "
      echo "[e2e]                 does not match testing repo branch ($MAVIS_TEST_BRANCH)."
      echo "[e2e]                 You may be running tests from a different branch than you desire."
  fi
fi

# Prepare Rails test DB

echo "[e2e] Preparing Rails test DB schema (RAILS_ENV=$RAILS_ENV)..."
RAILS_ENV="$RAILS_ENV" bin/rails db:prepare

# Start Rails server in end_to_end environment

echo "[e2e] Starting end_to_end stack with foreman..."
start_foreman() {
  if command -v setsid >/dev/null 2>&1; then
    setsid foreman start -f Procfile.e2e
  else
    # macOS does not ship a setsid binary; use Perl to create a new session.
    perl -MPOSIX -e 'POSIX::setsid() or die "setsid failed: $!"; exec @ARGV' foreman start -f Procfile.e2e
  fi
}

RAILS_ENV="$RAILS_ENV" SIDEKIQ_REDIS_URL="$E2E_REDIS_URL" start_foreman > /tmp/e2e-foreman.log 2>&1 &
E2E_PGID=$!


cleanup() {
  echo "[e2e] Cleaning up end_to_end stack..."

  if [[ -n "${E2E_PGID:-}" ]]; then
    echo "[e2e] Stopping process group PGID=$E2E_PGID..."

    # Try INT (like Ctrlâ€‘C) then TERM then KILL for the whole group
    for SIG in INT TERM KILL; do
      # If nothing in the group, stop
      if ! kill -0 "-$E2E_PGID" 2>/dev/null; then
        echo "[e2e] Process group $E2E_PGID already gone."
        break
      fi

      echo "[e2e] Sending $SIG to process group $E2E_PGID..."
      kill "-$SIG" "-$E2E_PGID" 2>/dev/null || true
      sleep 3
    done
  fi

  # Final safety net: ensure nothing is listening on $RAILS_PORT
  if command -v lsof >/dev/null 2>&1; then
    PIDS="$(lsof -ti tcp:"$RAILS_PORT" || true)"
    if [ -n "$PIDS" ]; then
      echo "[e2e] Forcing kill of processes on port $RAILS_PORT: $PIDS"
      kill -KILL $PIDS 2>/dev/null || true
    fi
  fi
}

trap cleanup EXIT INT TERM

# Wait for Rails health

echo "[e2e] Waiting for Rails to become healthy on $HEALTH_CHECK_URL..."
for i in {1..60}; do
  if curl -fsS "$HEALTH_CHECK_URL" > /dev/null 2>&1; then
    echo "[e2e] Rails is up."
    break
  fi
  sleep 1
  if [ "$i" -eq 60 ]; then
    echo "[e2e] ERROR: Rails server did not become ready in time." >&2
    exit 1
  fi
done

# Run pytest via uv

pushd "$MAVIS_TEST_REPO" > /dev/null

echo "[e2e] Running end-to-end tests via uv:"
echo "[e2e]   uv run pytest ${PYTEST_ARGS[*]}"
BASE_URL="http://localhost:${RAILS_PORT}" uv run pytest "${PYTEST_ARGS[@]}"
PYTEST_EXIT_CODE=$?

popd > /dev/null

exit $PYTEST_EXIT_CODE
