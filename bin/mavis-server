#!/usr/bin/env bash
# This script was generated by bashly 1.3.6 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
mavis_server_usage() {
  printf "mavis-server - Mavis server commands\n\n"

  printf "%s\n" "Usage:"
  printf "  mavis-server COMMAND\n"
  printf "  mavis-server [COMMAND] --help | -h\n"
  printf "  mavis-server --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Open shell on server\n" "shell"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
mavis_server_shell_usage() {
  printf "mavis-server shell - Open shell on server\n\n"
  printf "Alias: sh\n"
  echo

  printf "%s\n" "Usage:"
  printf "  mavis-server shell ENVIRONMENT [OPTIONS]\n"
  printf "  mavis-server shell --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--service, -s"
    printf "    Specify the service name. Ignored if using --task-id or --task-ip\n"
    echo

    # :flag.usage
    printf "  %s\n" "--task-id, -t TASK_ID"
    printf "    Specify the task ID directly\n"
    printf "    %s\n" "Conflicts: --task-ip"
    echo

    # :flag.usage
    printf "  %s\n" "--task-ip, -T TASK_IP"
    printf "    Specify the task by its IP address.\n"
    printf "    %s\n" "Conflicts: --task-id"
    echo

    # :flag.usage
    printf "  %s\n" "--exit-without-login, -x"
    printf "\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ENVIRONMENT"
    printf "    Specify the environment (cluster will be mavis-ENV)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  mavis-server shell test\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# lib/mavis-server/lib/mavis_server.sh
function confirm_production {
    if [ "$env" == "production" ]; then
        echo "You are trying to shell into a production container NOT Data-Replication. If you wish to proceed type 'production':"
        read -r confirm
        if [ "$confirm" != "production" ]; then
            echo "Validation failed. Exiting without shelling into production container."
            exit 1
        fi
    fi
}

function list_running_tasks {
    local service_name="$1"
    if [ -n "$service_name" ]; then
        aws ecs list-tasks --region "$region" --cluster "$cluster_name" --service-name "$service_name" --desired-status RUNNING | jq -r '.taskArns[]'
    else
        aws ecs list-tasks --region "$region" --cluster "$cluster_name" --desired-status RUNNING | jq -r '.taskArns[]'
    fi
}

function describe_tasks {
    local task_arns="$1"
    aws ecs describe-tasks --region "$region" --cluster "$cluster_name" --tasks $task_arns
}

function select_running_container {

    local task_data="$1"
    echo "$task_data" | jq -r '.containers | map(select(.lastStatus == "RUNNING" and .name == "application"))[0].name'
}

function set_service_name {
    # Set service to ops server for some environments, web server for others
    if [ -z "$service_name" ] && [[ "$env" != *data-replication ]]; then
        if [ "$env" == "qa" ] || [ "$env" == "production" ]; then
            service_name="mavis-$env-ops"
        else
            service_name="mavis-$env-web"
        fi
    fi
}

function set_cluster_name() {
    cluster_name="mavis-$env"
}

function set_task_info {
    if [ -n "$task_id" ]; then
        task_description=$(aws ecs describe-tasks --region "$region" --cluster "$cluster_name" --task "$task_id")
        if [ -z "$task_description" ] || echo "$task_description" | jq -e '.tasks | length == 0' > /dev/null; then
            echo "Task $task_id not found in cluster $cluster_name"
            exit 1
        fi
        task_status=$(echo "$task_description" | jq -r '.tasks[0].lastStatus')
        if [ "$task_status" != "RUNNING" ]; then
            echo "Task $task_id is not running (status: $task_status)"
            exit 1
        fi
        container_name=$(select_running_container "$(echo "$task_description" | jq '.tasks[0]')")
        if [ -z "$container_name" ] || [ "$container_name" = "null" ]; then
            echo "No running containers with valid runtimeId found in task $task_id"
            exit 1
        fi
    elif [ -n "$task_ip" ]; then
        task_arns=$(list_running_tasks "$service_name")
        if [ -z "$task_arns" ]; then
            echo "No running tasks found in cluster $cluster_name" $([ -n "$service_name" ] && echo "for service $service_name")
            exit 1
        fi
        tasks_description=$(describe_tasks "$task_arns")
        if [ -z "$tasks_description" ]; then
            echo "Failed to describe tasks in cluster $cluster_name"
            exit 1
        fi
        task_id=$(echo "$tasks_description" | jq -r '.tasks[] | select(.attachments[]?.details[]? | select(.name=="privateIPv4Address") | .value == "'"$task_ip"'") | .taskArn | split("/") | .[-1]' | head -n1)
        if [ -z "$task_id" ]; then
            echo "No running task found with IP $task_ip in cluster $cluster_name" $([ -n "$service_name" ] && echo "for service $service_name")
            exit 1
        fi
        task_description=$(echo "$tasks_description" | jq '.tasks[] | select(.taskArn | endswith("'"$task_id"'"))')
        container_name=$(select_running_container "$task_description")
        if [ -z "$container_name" ] || [ "$container_name" = "null" ]; then
            echo "No running containers with valid runtimeId found in task $task_id"
            exit 1
        fi
    else
        task_arns=$(list_running_tasks "$service_name")
        if [ -z "$task_arns" ]; then
            echo "No running tasks found in cluster $cluster_name" $([ -n "$service_name" ] && echo "for service $service_name")
            exit 1
        fi
        tasks_description=$(describe_tasks "$task_arns")
        if [ -z "$tasks_description" ]; then
            echo "Failed to describe tasks in cluster $cluster_name"
            exit 1
        fi
        selected_task=$(echo "$tasks_description" | jq '.tasks | map(select(.containers | map(.lastStatus == "RUNNING" and .runtimeId != null) | any)) | .[0]')
        if [ -z "$selected_task" ] || [ "$selected_task" = "null" ]; then
            echo "No running tasks with running containers with valid runtimeId found in cluster $cluster_name" $([ -n "$service_name" ] && echo "for service $service_name")
            exit 1
        fi
        task_id=$(echo "$selected_task" | jq -r '.taskArn | split("/") | .[-1]')
        container_name=$(select_running_container "$selected_task")
    fi
}

function authenticate_user {
    if ! aws sts get-caller-identity &>/dev/null; then
        if [[ -z "${args[--exit-without-login]}" ]]; then
            if ! aws sso login; then
                echo "Error: AWS CLI SSO login failed. Please log in to your AWS account."
                exit 1
            fi
        else
            echo "Error: AWS SSO login required. Please log in to your AWS account using 'aws sso login'."
            exit 1
        fi
    fi
}

# :command.command_functions
# :command.function
mavis_server_shell_command() {

  # lib/mavis-server/shell_command.sh
  region="eu-west-2"
  service_name=""
  env=${args[environment]}
  task_id=${args[--task-id]}
  task_ip=${args[--task-ip]}

  if [ "$env" == "production" ]; then
      echo "You are trying to shell into a production container NOT Data-Replication. If you wish to proceed type 'production':"
      read -r confirm
      if [ "$confirm" != "production" ]; then
          echo "Validation failed. Exiting without shelling into production container."
          exit 1
      fi
  fi

  set_service_name
  set_cluster_name

  authenticate_user

  set_task_info

  echo "Opening an interactive shell in task $task_id" of service "$service_name"
  aws ecs execute-command --region "$region" \
      --cluster "$cluster_name" \
      --task "$task_id" \
      --container "$container_name" \
      --command "/rails/bin/docker-entrypoint /bin/bash" \
      --interactive

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        mavis_server_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    shell | sh)
      action="shell"
      shift
      mavis_server_shell_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      mavis_server_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
mavis_server_shell_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        mavis_server_shell_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shell"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --service | -s)

        # :flag.case_no_arg
        args['--service']=1
        shift
        ;;

      # :flag.case
      --task-id | -t)
        # :flag.conflicts
        if [[ -n "${args['--task-ip']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--task-ip" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--task-id']="$2"
          shift
          shift
        else
          printf "%s\n" "--task-id requires an argument: --task-id, -t TASK_ID" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --task-ip | -T)
        # :flag.conflicts
        if [[ -n "${args['--task-id']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--task-id" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--task-ip']="$2"
          shift
          shift
        else
          printf "%s\n" "--task-ip requires an argument: --task-ip, -T TASK_IP" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --exit-without-login | -x)

        # :flag.case_no_arg
        args['--exit-without-login']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['environment']+x} ]]; then
          args['environment']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['environment']+x} ]]; then
    printf "missing required argument: ENVIRONMENT\nusage: mavis-server shell ENVIRONMENT [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.0.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "shell") mavis_server_shell_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
